with Ada.Text_IO; use Ada.Text_IO;
with Ada.Unchecked_Deallocation;

package body arbre_de_huffman is

    procedure Free is
            new Ada.Unchecked_Deallocation (Object => T_Feuille, Name => Arbre);


    type A_Arbres is array (1..256) of Arbre;

    type L_Arbre is record
        Taille : Integer;
        Foret : A_Arbres;
    end record ;

    type A_Caracteres is array (1..257) of Character;

    type L_Caractere is record
        Taille : Integer;
        Caracteres : A_Caracteres;
    end record;

    type A_Complets is array (1..256) of Boolean;

    type L_Complets is record
        Taille : Integer;
        Complets : A_Complets;
    end record;


    procedure Calculer_Freq(Table : out T_Frequences; Texte : in Unbounded_String) is
        Copie_Texte : Unbounded_String := Texte;
        Compteur, Longueur, Nb_Supprimer : Integer;
        Caractere : Character;
    begin
        -- Pacours de tout le texte
        while Length(Copie_Texte) > 0 loop

            -- Initialisation des variables
            compteur := 0;
            Longueur := Length(Copie_Texte);
            Nb_Supprimer := 0;
            Caractere := To_String(Copie_Texte)(0);

            -- Compte de la fréquence et suppression de toutes les occurences du Caractere
            for i in 1..Longueur loop
                if To_String(Copie_Texte)(i-Nb_Supprimer) = Caractere then
                    Compteur := Compteur +1;
                    Copie_Texte := Delete(Copie_Texte, i-Nb_Supprimer, i-Nb_Supprimer);
                    Nb_Supprimer := Nb_Supprimer + 1;
                else
                    null;
                end if;
            end loop;

            -- Ajouter le caractère et sa fréquence dans la table
            Table.Taille := Table.Taille + 1;
            Table.Tableau(Table.Taille).Caractere := Caractere;
            Table.Tableau(Table.Taille).Frequence := Compteur;
        end loop;

    end Calculer_Freq;




    procedure Construire_Arbre(Arbre_Huff : out Arbre; Table : in T_Frequences) is

        procedure Lister_Feuilles (Table : in T_Frequences; Liste_Arbre : out L_Arbre) is
        begin
            null;
        end Lister_Feuilles;


        Liste_Arbres : L_Arbre;
        freq_min1, freq_min2, indice_Arbre1, indice_Arbre2 : Integer;
    begin
        Lister_Feuilles(Table, Liste_Arbres);
        while Liste_Arbres.Taille > 1 loop
            -- Determiner les deux arbres ayant la plus petite fréquence
            if Liste_Arbres.Foret(1).Frequence <= Liste_Arbres.Foret(2).Frequence then
                freq_min1 := Liste_Arbres.Foret(1).Frequence;
                freq_min2 := Liste_Arbres.Foret(2).Frequence;
                indice_Arbre1 := 1;
                indice_Arbre2 := 2;
            else
                freq_min1 := Liste_Arbres.Foret(2).Frequence;
                freq_min2 := Liste_Arbres.Foret(1).Frequence;
                indice_Arbre1 := 2;
                indice_Arbre2 := 1;
            end if;

            for indice in 3..Liste_Arbres.Taille loop
                if  freq_min1 <= Liste_Arbres.Foret(indice).Frequence and freq_min2 > Liste_Arbres.Foret(indice).Frequence then
                    freq_min2 := Liste_Arbres.Foret(indice).Frequence;
                    indice_Arbre2 := indice;
                elsif freq_min1 > Liste_Arbres.Foret(indice).Frequence then
                    freq_min2 := freq_min1;
                    indice_Arbre2 := indice_Arbre1;
                    freq_min1 := Liste_Arbres.Foret(indice).Frequence;
                    indice_Arbre1 := indice;
                end if;
            end loop;

            -- Assembler ces deux arbres
            Assembler_2arbres (Liste_Arbres, indice_Arbre1, indice_Arbre2);

            -- Placer le dernier Arbre de la Liste_Arbre dans l'espace de Second arbre
            Liste_Arbres.Foret(indice_Arbre2) := Liste_Arbres.Foret(Liste_Arbres.Taille);
            Liste_Arbres.Foret(Liste_Arbres.Taille) := null;
            Liste_Arbres.Taille := Liste_Arbres.Taille - 1;
        end loop;

        -- Attribuer à Arbre_Huff sa valeur
        Arbre_Huff := Liste_Arbres.Foret(1);
        Liste_Arbres.Foret(1) := null;
        Liste_Arbres.Taille := 0;
    end Construire_Arbre;




    procedure Vider_Arbre(Arbre_Huff : in out Arbre) is
    begin
        if Arbre_Huff /= null then
            Vider_Arbre(Arbre_Huff.all.Fils_G);
            Vider_Arbre(Arbre_Huff.all.Fils_D);
            Free(Arbre_Huff);
        else
            null;
        end if;
    end Vider_Arbre;



    procedure Fabriquer_Dict(Dict : in out T_Dictionnaire; Arbre_Huff : in Arbre) is

        procedure Fabriquer_Dict_recursive(Arbre : in Arbre) is
        begin
            null;
        end Fabriquer_Dict_recursive;

    begin
        -- Initialiser Dict
        for k in 1..27 loop
            Dict(k) := null;
        end loop;

        Fabriquer_Dict_recursive(Dict, Arbre_Huff, To_Unbounded_String(""), T_Octet(0));
    end Fabriquer_Dict;


    function La_Donnee_Dict(Dict : in T_Dictionnaire; Caractere : in Character; Fin : in Boolean) return Unbounded_String is

        function Code_LCA(Arbre : in Arbre) return Arbre is
        begin
            return null;
        end Code_LCA;

    begin
        if Fin then
            return Dict(1).Code_Huff;
        end if;

        return Code_LCA(Caractere, Dict(Hachage(Caractere, False)));
    end La_Donnee_Dict;



    function Le_Caractere_Dict(Dict : in T_Dictionnaire; Code : in Unbounded_String) return Character is
        indice : Integer := 1;
        Caractere : Character;
        Trouve : Boolean := False;
    begin
        loop
            Caractere_LCA(Code, dict(indice), Caractere, Trouve);
            indice := indice + 1;

            exit when Trouve;
        end loop;

        return Caractere;

    end Le_Caractere_Dict;



    procedure Vider_Dict(Dict : in out T_Dictionnaire) is
        procedure Vider_LCA(Arbre : in Arbre) is
        begin
            null;
        end Vider_LCA;

    begin
        for i in 1..27 loop
            Vider_LCA(Dict(i));
        end loop;

    end Vider_Dict;



    function Code_Est_Present_Dict(Code : in Unbounded_String; Dict : in T_Dictionnaire) return Boolean is
        indice : Integer := 1;
        Trouve : Boolean := False;
    begin
        loop
            Caractere_LCA(Code, Dict(indice), Caractere, Trouve);
            indice := indice + 1;
            exit when (Trouve or indice > 27);
        end loop;
        return Trouve;
    end Code_Est_Present_Dict;


    procedure Recuperer_Arbre(Arbre_Huff : out Arbre; Texte : in out Unbounded_String) is
        Liste_Caractere : L_Caractere;
        nbr0, nbr1 : Integer := 0;
        Liste_Arbre : L_Arbre;
        Liste_Complet : L_Complets;

    begin

        if length(Texte) = 16 then
            -- Le fichier est vide
            Arbre_Huff := new T_Feuille;
            Arbre_Huff.all.Caractere := Character'Val(0);
            Arbre_Huff.all.Frequence := 0;
            Arbre_Huff.all.Fils_G := null;
            Arbre_Huff.all.Fils_D := null;
            Texte := To_Unbounded_String("0000000");
        else
            -- Obtenir la portion de caractere de la table de Huffman
            -- Mettre le '\$' en premiere position de la liste des caracteres
            Liste_Caractere.Taille := 1;
            Liste_Caractere.Caracteres := Convertir_Binaire_Caractere(To_String(Texte)(1..8));
            Texte := Delete(Texte, 1, 8);

            -- Mettre les caractères suivant
            while To_String(Texte)(1..8)/=To_String(Texte)(9..16) loop
                Liste_Caractere.Taille := Liste_Caractere.Taille + 1;
                Liste_Caractere.Caracteres(Liste_Caractere.Taille) := Convertir_Binaire_Caractere(To_String(Texte)(1..8));
                Texte := Delete(Texte, 1, 8);
            end loop;

            -- Mettre le dernier caracteres dans la liste
            Liste_Caractere.Taille := Liste_Caractere.Taille + 1;
            Liste_Caractere.Caracteres(Liste_Caractere.Taille) := Convertir_Binaire_Caractere(To_String(Texte)(1..8));
            Texte := Delete(Texte, 1, 16);

            -- Créer l'arbre de Huffman à l'aide de sa forme binaire

            -- Initialiser les compteur
            Liste_Complet.Taille := 0;
            Liste_Arbre.Taille := 0;

            while nbr0 > nbr1 loop
                -- Agrandir l'arbre selon le bit lu
                if To_String(Texte)(1) = '0' then
                    -- Rajouter une racine à l'arbre
                    nbr0 := nbr0 + 1;
                    Liste_Complet.Taille := Liste_Complet.Taille + 1;
                    Liste_Complet.Complets(Liste_Complet.Taille) := False;

                else
                    -- Rajouter une feuille à l'arbre
                    nbr1 := nbr1 + 1;
                    -- Creer La feuille
                    Liste_Arbre.Taille := Liste_Arbre.Taille + 1;
                    Liste_Arbre.Foret(Liste_Arbre.Taille) := new T_Feuille;

                    if nbr1 = Character'pos(Liste_Caractere.Caracteres(1)) then
                        -- Donner les caracteristique de la feuille '\$'
                        Liste_Arbre.Foret(Liste_Arbre.Taille).all.Frequence := 0;
                        Liste_Arbre.Foret(Liste_Arbre.Taille).all.Caractere := Character'Val(0);
                    else
                        -- Donner les caracteristique de la nouvelle feuille differente de '\$'
                        Liste_Arbre.Foret(Liste_Arbre.Taille).all.Frequence := 1;
                        if nbr1 < Character'Pos(Liste_Caractere.Caracteres(1)) then
                            Liste_Arbre.Foret(Liste_Arbre.Taille).all.Caractere := Liste_Caractere.Caracteres(nbr1 + 1);
                        else
                            Liste_Arbre.Foret(Liste_Arbre.Taille).all.Caractere := Liste_Caractere.Caracteres(nbr1);
                        end if;

                    end if;

                    Liste_Arbre.Foret(Liste_Arbre.Taille).all.Fils_G := null;
                    Liste_Arbre.Foret(Liste_Arbre.Taille).all.Fils_D := null;


                    -- Ajouter la feuille à l'arbre
                    while Liste_Complet.Complets(Liste_Complet.Taille) loop
                        Assembler_2arbres(Liste_Arbre, Liste_Arbre.Taille-1, Liste_Arbre.Taille);
                        Liste_Arbre.Foret(Liste_Arbre.Taille) := null;
                        Liste_Arbre.Taille := Liste_Arbre.Taille - 1;
                        Liste_Complet.Taille := Liste_Complet.Taille - 1;


                        if Liste_Complet.Taille > 0 then
                            Liste_Complet.Complets(Liste_Complet.Taille) := True;
                        end if;

                    end if;


                    Texte := Delete(Texte,1, 1);
                end loop;

                Arbre_Huff := Liste_Arbre.Foret(1);
                Liste_Arbre.Foret(1) := null;
            end if;

        end Recuperer_Arbre;

        function Arbre_En_Binaire(Arbre_Huff : in Arbre) return Unbounded_String is
        begin
            if Arbre_Huff.all.Fils_G = null then
                return To_Unbounded_String("1");
            end if;
            return To_Unbounded_String("0") & Arbre_En_Binaire(Arbre_Huff.all.Fils_G) & Arbre_En_Binaire(Arbre_Huff.all.Fils_D);
        end Arbre_En_Binaire;



        function Table_En_Binaire(Dict : in T_Dictionnaire) return Unbounded_String is
            texte : Unbounded_String;
        begin
            texte := To_Unbounded_String("" & Dict(1).all.Caractere);
            Ajouter_Caractere_Code(To_Unbounded_String(""), Texte, Dict, Dict(1).all.Code);
            texte := texte & To_String(texte)(Length(texte));
            Convertir_Binaire(texte);
            return texte;

        end Table_En_Binaire;



        procedure Afficher_Arbre(Arbre_Huff : in Arbre) is
        begin
            if Arbre_Huff^.Fils_G/=null then
                Put("(" & Entier'Image(Arbre_Huff.all.Frequence) & ")")
                        New_Line;
                AFFICHER_ARBRE_RECURSIF(To_Unbounded_String("0"),Arbre_Huff.all.Fils_G);
                AFFICHER_ARBRE_RECURSIF(To_Unbounded_String("1"),Arbre_Huff.all.Fils_D);
            else
                Put("- - 0 - - (0) '\$'");
                New_Line;
            end if;
        end Afficher_Arbre;



        procedure Afficher_Dict(Dictionnaire : in T_Dictionnaire) is
        begin
            null;
        end Afficher_Dict;


    end arbre_de_huffman;
