with Ada.Text_IO; use Ada.Text_IO;
with Ada.Unchecked_Deallocation;

package body arbre_de_huffman is

    procedure Free is
            new Ada.Unchecked_Deallocation (Object => T_Feuille, Name => Arbre);

    procedure Calculer_Freq(Table : out T_Frequences; Texte : in Unbounded_String) is
        Copie_Texte : Unbounded_String := Texte;
        Compteur, Longueur, Nb_Supprimer : Integer;
        Caractere : Character;
    begin
        -- Pacours de tout le texte
        while Length(Copie_Texte) > 0 loop

            -- Initialisation des variables
            compteur := 1;
            Longueur := Length(Copie_Texte);
            Nb_Supprimer := 0;
            Caractere := Copie_Texte(0);

            -- Compte de la fréquence et suppression de toutes les occurences du Caractere
            for i in 0..Longueur loop
                if Copie_Texte(i-Nb_Supprimer) = Caractere then
                    Compteur := Compteur +1;
                    Copie_Texte := Delete(Copie_Texte, i-Nb_Supprimer, i-Nb_Supprimer);
                    Nb_Supprimer := Nb_Supprimer + 1;
                else
                    null;
                end if;
            end loop;

            -- Ajouter le caractère et sa fréquence dans la table
            Table.Taille := Table.Taille + 1;
            Table.Tableau(Table.Taille).Caractere := Caractere;
            Table.Tableau(Table.Taille).Frequence := Compteur;
        end loop;

    end Calculer_Freq;




    procedure Construire_Arbre(Arbre_Huff : out Arbre; Table : in T_Frequences) is
        Liste_Arbres : L_Arbres;
        freq_min1, freq_min2, indice_Arbre1, indice_Arbre2 : Integer;
    begin
        LISTER(Table, Liste_Arbres);
        while Liste_Arbres.Taille > 1 loop
            -- Determiner les deux arbres ayant la plus petite fréquence
            if Liste_Arbres(1).all.Frequence <= Liste_Arbres(2).all.Frequence then
                freq_min1 := Liste_Arbres(1).all.Frequence;
                freq_min2 := Liste_Arbres(2).all.Frequence;
                indice_Arbre1 := 1;
                indice_Arbre2 := 2;
            else
                freq_min1 := Liste_Arbres(2).all.Frequence;
                freq_min2 := Liste_Arbres(1).all.Frequence;
                indice_Arbre1 := 2;
                indice_Arbre2 := 1;
            end if;

            for indice in 3..Liste_Arbres.Taille loop
                if  freq_min1 <= Liste_Arbres(indice).all.Frequence and freq_min2 > Liste_Arbres(indice).all.Frequence then
                    freq_min2 := Liste_Arbres(indice).all.Frequence;
                    indice_Arbre2 := indice;
                elsif freq_min1 > Liste_Arbres(indice)..all.Frequence then
                    freq_min2 := freq_min1;
                    indice_Arbre2 := indice_Arbre1;
                    freq_min1 := Liste_Arbres(indice).all.Frequence;
                    indice_Arbre1 := indice;
                end if;
            end loop;

            -- Assembler ces deux arbres
            Assembler_2arbres (Liste_Arbres, indice_Arbre1, indice_Arbre2);

            -- Placer le dernier Arbre de la Liste_Arbre dans l'espace de Second arbre
            Liste_Arbres(indice_Arbre2) := Liste_Arbres(Liste_Arbres.Taille);
            Liste_Arbres(Liste_Arbres.Taille) := null;
            Liste_Arbres.Taille := Liste_Arbres.Taille - 1;
        end loop;

        -- Attribuer à Arbre_Huff sa valeur
        Arbre_Huff := Liste_Arbres(1);
        Liste_Arbres(1) := null;
        Liste_Arbres.Taille := 0;
    end Construire_Arbre;




    procedure Vider_Arbre(Arbre_Huff : in out Arbre) is
    begin
        if Arbre_Huff /= null then
            Vider_Arbre(Arbre_Huff.all.Fils_G);
            Vider_Arbre(Arbre_Huff.all.Fils_D);
            Free(Arbre_Huff);
        else
            null;
        end if;
    end Vider_Arbre;



    procedure Fabriquer_Dict(Dict : in out T_Dictionnaire; Arbre_Huff : in Arbre) is
    begin
        null;
    end Fabriquer_Dict;


    function La_Donnee_Dict(Dict : in T_Dictionnaire; Caractere : in Character; Fin : in Boolean) return Unbounded_String is
    begin
        return null;
    end La_Donnee_Dict;



    function Le_Caractere_Dict(Dict : in T_Dictionnaire; Code : in Unbounded_String) return Character is
    begin
        return null;
    end Le_Caractere_Dict;



    procedure Vider_Dict(Dict : in out T_Dictionnaire) is
    begin
        null;
    end Vider_Dict;



    procedure Recuperer_Arbre(Arbre_Huff : out Arbre; Texte : in out Unbounded_String) is
    begin
        null;
    end Recuperer_Arbre;



    function Code_Est_Present_Dict(Code : in Unbounded_String; Dict : in T_Dictionnaire) return Boolean is
    begin
        return False
    end Code_Est_Present_Dict;



    function Arbre_En_Binaire(Arbre_Huff : in Arbre) return Unbounded_String is
    begin
        return False;
    end Arbre_En_Binaire;



    function Table_En_Binaire(Dict : in T_Dictionnaire) return Unbounded_String is
    begin
        return null;
    end Table_En_Binaire;



    procedure Afficher_Arbre(Arbre_Huff : in Arbre) is
    begin
        null
    end Afficher_Arbre;



    procedure Afficher_Dict(Dictionnaire : in T_Dictionnaire) is
    begin
        null
    end Afficher_Dict;


end arbre_de_huffman;
